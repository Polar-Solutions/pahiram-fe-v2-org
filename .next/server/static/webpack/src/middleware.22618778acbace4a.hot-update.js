"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("src/middleware",{

/***/ "(middleware)/./node_modules/path-to-regexp/dist/index.js":
/*!***************************************************!*\
  !*** ./node_modules/path-to-regexp/dist/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TokenData = void 0;\nexports.parse = parse;\nexports.compile = compile;\nexports.match = match;\nexports.pathToRegexp = pathToRegexp;\nconst DEFAULT_DELIMITER = \"/\";\nconst NOOP_VALUE = (value) => value;\nconst ID_CHAR = /^\\p{XID_Continue}$/u;\nconst DEBUG_URL = \"https://git.new/pathToRegexpError\";\nconst SIMPLE_TOKENS = {\n    \"!\": \"!\",\n    \"@\": \"@\",\n    \";\": \";\",\n    \",\": \",\",\n    \"*\": \"*\",\n    \"+\": \"+\",\n    \"?\": \"?\",\n    \"{\": \"{\",\n    \"}\": \"}\",\n};\n/**\n * Tokenize input string.\n */\nfunction lexer(str) {\n    const chars = [...str];\n    const tokens = [];\n    let i = 0;\n    while (i < chars.length) {\n        const value = chars[i];\n        const type = SIMPLE_TOKENS[value];\n        if (type) {\n            tokens.push({ type, index: i++, value });\n            continue;\n        }\n        if (value === \"\\\\\") {\n            tokens.push({ type: \"ESCAPED\", index: i++, value: chars[i++] });\n            continue;\n        }\n        if (value === \":\") {\n            let name = \"\";\n            while (ID_CHAR.test(chars[++i])) {\n                name += chars[i];\n            }\n            if (!name) {\n                throw new TypeError(`Missing parameter name at ${i}`);\n            }\n            tokens.push({ type: \"NAME\", index: i, value: name });\n            continue;\n        }\n        if (value === \"(\") {\n            const pos = i++;\n            let count = 1;\n            let pattern = \"\";\n            if (chars[i] === \"?\") {\n                throw new TypeError(`Pattern cannot start with \"?\" at ${i}`);\n            }\n            while (i < chars.length) {\n                if (chars[i] === \"\\\\\") {\n                    pattern += chars[i++] + chars[i++];\n                    continue;\n                }\n                if (chars[i] === \")\") {\n                    count--;\n                    if (count === 0) {\n                        i++;\n                        break;\n                    }\n                }\n                else if (chars[i] === \"(\") {\n                    count++;\n                    if (chars[i + 1] !== \"?\") {\n                        throw new TypeError(`Capturing groups are not allowed at ${i}`);\n                    }\n                }\n                pattern += chars[i++];\n            }\n            if (count)\n                throw new TypeError(`Unbalanced pattern at ${pos}`);\n            if (!pattern)\n                throw new TypeError(`Missing pattern at ${pos}`);\n            tokens.push({ type: \"PATTERN\", index: i, value: pattern });\n            continue;\n        }\n        tokens.push({ type: \"CHAR\", index: i, value: chars[i++] });\n    }\n    tokens.push({ type: \"END\", index: i, value: \"\" });\n    return new Iter(tokens);\n}\nclass Iter {\n    constructor(tokens) {\n        this.tokens = tokens;\n        this.index = 0;\n    }\n    peek() {\n        return this.tokens[this.index];\n    }\n    tryConsume(type) {\n        const token = this.peek();\n        if (token.type !== type)\n            return;\n        this.index++;\n        return token.value;\n    }\n    consume(type) {\n        const value = this.tryConsume(type);\n        if (value !== undefined)\n            return value;\n        const { type: nextType, index } = this.peek();\n        throw new TypeError(`Unexpected ${nextType} at ${index}, expected ${type}: ${DEBUG_URL}`);\n    }\n    text() {\n        let result = \"\";\n        let value;\n        while ((value = this.tryConsume(\"CHAR\") || this.tryConsume(\"ESCAPED\"))) {\n            result += value;\n        }\n        return result;\n    }\n    modifier() {\n        return this.tryConsume(\"?\") || this.tryConsume(\"*\") || this.tryConsume(\"+\");\n    }\n}\n/**\n * Tokenized path instance. Can we passed around instead of string.\n */\nclass TokenData {\n    constructor(tokens, delimiter) {\n        this.tokens = tokens;\n        this.delimiter = delimiter;\n    }\n}\nexports.TokenData = TokenData;\n/**\n * Parse a string for the raw tokens.\n */\nfunction parse(str, options = {}) {\n    const { encodePath = NOOP_VALUE, delimiter = encodePath(DEFAULT_DELIMITER) } = options;\n    const tokens = [];\n    const it = lexer(str);\n    let key = 0;\n    do {\n        const path = it.text();\n        if (path)\n            tokens.push(encodePath(path));\n        const name = it.tryConsume(\"NAME\");\n        const pattern = it.tryConsume(\"PATTERN\");\n        if (name || pattern) {\n            tokens.push({\n                name: name || String(key++),\n                pattern,\n            });\n            const next = it.peek();\n            if (next.type === \"*\") {\n                throw new TypeError(`Unexpected * at ${next.index}, you probably want \\`/*\\` or \\`{/:foo}*\\`: ${DEBUG_URL}`);\n            }\n            continue;\n        }\n        const asterisk = it.tryConsume(\"*\");\n        if (asterisk) {\n            tokens.push({\n                name: String(key++),\n                pattern: `(?:(?!${escape(delimiter)}).)*`,\n                modifier: \"*\",\n                separator: delimiter,\n            });\n            continue;\n        }\n        const open = it.tryConsume(\"{\");\n        if (open) {\n            const prefix = it.text();\n            const name = it.tryConsume(\"NAME\");\n            const pattern = it.tryConsume(\"PATTERN\");\n            const suffix = it.text();\n            const separator = it.tryConsume(\";\") && it.text();\n            it.consume(\"}\");\n            const modifier = it.modifier();\n            tokens.push({\n                name: name || (pattern ? String(key++) : \"\"),\n                prefix: encodePath(prefix),\n                suffix: encodePath(suffix),\n                pattern,\n                modifier,\n                separator,\n            });\n            continue;\n        }\n        it.consume(\"END\");\n        break;\n    } while (true);\n    return new TokenData(tokens, delimiter);\n}\n/**\n * Compile a string to a template function for the path.\n */\nfunction compile(path, options = {}) {\n    const data = path instanceof TokenData ? path : parse(path, options);\n    return compileTokens(data, options);\n}\n/**\n * Convert a single token into a path building function.\n */\nfunction tokenToFunction(token, encode) {\n    if (typeof token === \"string\") {\n        return () => token;\n    }\n    const encodeValue = encode || NOOP_VALUE;\n    const repeated = token.modifier === \"+\" || token.modifier === \"*\";\n    const optional = token.modifier === \"?\" || token.modifier === \"*\";\n    const { prefix = \"\", suffix = \"\", separator = suffix + prefix } = token;\n    if (encode && repeated) {\n        const stringify = (value, index) => {\n            if (typeof value !== \"string\") {\n                throw new TypeError(`Expected \"${token.name}/${index}\" to be a string`);\n            }\n            return encodeValue(value);\n        };\n        const compile = (value) => {\n            if (!Array.isArray(value)) {\n                throw new TypeError(`Expected \"${token.name}\" to be an array`);\n            }\n            if (value.length === 0)\n                return \"\";\n            return prefix + value.map(stringify).join(separator) + suffix;\n        };\n        if (optional) {\n            return (data) => {\n                const value = data[token.name];\n                if (value == null)\n                    return \"\";\n                return value.length ? compile(value) : \"\";\n            };\n        }\n        return (data) => {\n            const value = data[token.name];\n            return compile(value);\n        };\n    }\n    const stringify = (value) => {\n        if (typeof value !== \"string\") {\n            throw new TypeError(`Expected \"${token.name}\" to be a string`);\n        }\n        return prefix + encodeValue(value) + suffix;\n    };\n    if (optional) {\n        return (data) => {\n            const value = data[token.name];\n            if (value == null)\n                return \"\";\n            return stringify(value);\n        };\n    }\n    return (data) => {\n        const value = data[token.name];\n        return stringify(value);\n    };\n}\n/**\n * Transform tokens into a path building function.\n */\nfunction compileTokens(data, options) {\n    const { encode = encodeURIComponent, loose = true, validate = true, strict = false, } = options;\n    const flags = toFlags(options);\n    const stringify = toStringify(loose, data.delimiter);\n    const sources = toRegExpSource(data, stringify, [], flags, strict);\n    // Compile all the tokens into regexps.\n    const encoders = data.tokens.map((token, index) => {\n        const fn = tokenToFunction(token, encode);\n        if (!validate || typeof token === \"string\")\n            return fn;\n        const validRe = new RegExp(`^${sources[index]}$`, flags);\n        return (data) => {\n            const value = fn(data);\n            if (!validRe.test(value)) {\n                throw new TypeError(`Invalid value for \"${token.name}\": ${JSON.stringify(value)}`);\n            }\n            return value;\n        };\n    });\n    return function path(data = {}) {\n        let path = \"\";\n        for (const encoder of encoders)\n            path += encoder(data);\n        return path;\n    };\n}\n/**\n * Create path match function from `path-to-regexp` spec.\n */\nfunction match(path, options = {}) {\n    const { decode = decodeURIComponent, loose = true } = options;\n    const data = path instanceof TokenData ? path : parse(path, options);\n    const stringify = toStringify(loose, data.delimiter);\n    const keys = [];\n    const re = tokensToRegexp(data, keys, options);\n    const decoders = keys.map((key) => {\n        if (decode && (key.modifier === \"+\" || key.modifier === \"*\")) {\n            const { prefix = \"\", suffix = \"\", separator = suffix + prefix } = key;\n            const re = new RegExp(stringify(separator), \"g\");\n            return (value) => value.split(re).map(decode);\n        }\n        return decode || NOOP_VALUE;\n    });\n    return function match(input) {\n        const m = re.exec(input);\n        if (!m)\n            return false;\n        const { 0: path, index } = m;\n        const params = Object.create(null);\n        for (let i = 1; i < m.length; i++) {\n            if (m[i] === undefined)\n                continue;\n            const key = keys[i - 1];\n            const decoder = decoders[i - 1];\n            params[key.name] = decoder(m[i]);\n        }\n        return { path, index, params };\n    };\n}\n/**\n * Escape a regular expression string.\n */\nfunction escape(str) {\n    return str.replace(/([.+*?^${}()[\\]|/\\\\])/g, \"\\\\$1\");\n}\n/**\n * Escape and repeat loose characters for regular expressions.\n */\nfunction looseReplacer(value, loose) {\n    const escaped = escape(value);\n    return loose ? `(?:${escaped})+(?!${escaped})` : escaped;\n}\n/**\n * Encode all non-delimiter characters using the encode function.\n */\nfunction toStringify(loose, delimiter) {\n    if (!loose)\n        return escape;\n    const re = new RegExp(`(?:(?!${escape(delimiter)}).)+|(.)`, \"g\");\n    return (value) => value.replace(re, looseReplacer);\n}\n/**\n * Get the flags for a regexp from the options.\n */\nfunction toFlags(options) {\n    return options.sensitive ? \"\" : \"i\";\n}\n/**\n * Expose a function for taking tokens and returning a RegExp.\n */\nfunction tokensToRegexp(data, keys, options) {\n    const { trailing = true, loose = true, start = true, end = true, strict = false, } = options;\n    const flags = toFlags(options);\n    const stringify = toStringify(loose, data.delimiter);\n    const sources = toRegExpSource(data, stringify, keys, flags, strict);\n    let pattern = start ? \"^\" : \"\";\n    pattern += sources.join(\"\");\n    if (trailing)\n        pattern += `(?:${stringify(data.delimiter)})?`;\n    pattern += end ? \"$\" : `(?=${escape(data.delimiter)}|$)`;\n    return new RegExp(pattern, flags);\n}\n/**\n * Convert a token into a regexp string (re-used for path validation).\n */\nfunction toRegExpSource(data, stringify, keys, flags, strict) {\n    const defaultPattern = `(?:(?!${escape(data.delimiter)}).)+?`;\n    let backtrack = \"\";\n    let safe = true;\n    return data.tokens.map((token, index) => {\n        if (typeof token === \"string\") {\n            backtrack = token;\n            return stringify(token);\n        }\n        const { prefix = \"\", suffix = \"\", separator = suffix + prefix, modifier = \"\", } = token;\n        const pre = stringify(prefix);\n        const post = stringify(suffix);\n        if (token.name) {\n            const pattern = token.pattern ? `(?:${token.pattern})` : defaultPattern;\n            const re = checkPattern(pattern, token.name, flags);\n            safe || (safe = safePattern(re, prefix || backtrack));\n            if (!safe) {\n                throw new TypeError(`Ambiguous pattern for \"${token.name}\": ${DEBUG_URL}`);\n            }\n            safe = !strict || safePattern(re, suffix);\n            backtrack = \"\";\n            keys.push(token);\n            if (modifier === \"+\" || modifier === \"*\") {\n                const mod = modifier === \"*\" ? \"?\" : \"\";\n                const sep = stringify(separator);\n                if (!sep) {\n                    throw new TypeError(`Missing separator for \"${token.name}\": ${DEBUG_URL}`);\n                }\n                safe || (safe = !strict || safePattern(re, separator));\n                if (!safe) {\n                    throw new TypeError(`Ambiguous pattern for \"${token.name}\" separator: ${DEBUG_URL}`);\n                }\n                safe = !strict;\n                return `(?:${pre}(${pattern}(?:${sep}${pattern})*)${post})${mod}`;\n            }\n            return `(?:${pre}(${pattern})${post})${modifier}`;\n        }\n        return `(?:${pre}${post})${modifier}`;\n    });\n}\nfunction checkPattern(pattern, name, flags) {\n    try {\n        return new RegExp(`^${pattern}$`, flags);\n    }\n    catch (err) {\n        throw new TypeError(`Invalid pattern for \"${name}\": ${err.message}`);\n    }\n}\nfunction safePattern(re, value) {\n    return value ? !re.test(value) : false;\n}\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n */\nfunction pathToRegexp(path, options = {}) {\n    const data = path instanceof TokenData ? path : parse(path, options);\n    const keys = [];\n    const regexp = tokensToRegexp(data, keys, options);\n    return Object.assign(regexp, { keys });\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKG1pZGRsZXdhcmUpLy4vbm9kZV9tb2R1bGVzL3BhdGgtdG8tcmVnZXhwL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYixlQUFlO0FBQ2YsYUFBYTtBQUNiLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0EscUJBQXFCLGFBQWE7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLEtBQUs7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sS0FBSztBQUNYLE1BQU0sS0FBSztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix5QkFBeUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGdEQUFnRDtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLEVBQUU7QUFDbkU7QUFDQSwwQkFBMEIscUNBQXFDO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLEVBQUU7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRkFBbUYsRUFBRTtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELElBQUk7QUFDakU7QUFDQSwwREFBMEQsSUFBSTtBQUM5RCwwQkFBMEIsMkNBQTJDO0FBQ3JFO0FBQ0E7QUFDQSxzQkFBc0IsMkNBQTJDO0FBQ2pFO0FBQ0Esa0JBQWtCLGtDQUFrQztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Is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QUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix3RUFBd0U7QUFDeEY7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0EsOERBQThELFdBQVcsS0FBSyxVQUFVO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsV0FBVyxLQUFLLFVBQVU7QUFDNUY7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLFdBQVcsZUFBZSxVQUFVO0FBQ3RHO0FBQ0E7QUFDQSw2QkFBNkIsSUFBSSxHQUFHLFFBQVEsS0FBSyxJQUFJLEVBQUUsUUFBUSxLQUFLLEtBQUssR0FBRyxJQUFJO0FBQ2hGO0FBQ0EseUJBQXlCLElBQUksR0FBRyxRQUFRLEdBQUcsS0FBSyxHQUFHLFNBQVM7QUFDNUQ7QUFDQSxxQkFBcUIsSUFBSSxFQUFFLEtBQUssR0FBRyxTQUFTO0FBQzVDLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsUUFBUTtBQUN0QztBQUNBO0FBQ0Esb0RBQW9ELEtBQUssS0FBSyxZQUFZO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw0REFBNEQ7QUFDM0U7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLE1BQU07QUFDekM7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcGF0aC10by1yZWdleHAvZGlzdC9pbmRleC5qcz8yZWRjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Ub2tlbkRhdGEgPSB2b2lkIDA7XG5leHBvcnRzLnBhcnNlID0gcGFyc2U7XG5leHBvcnRzLmNvbXBpbGUgPSBjb21waWxlO1xuZXhwb3J0cy5tYXRjaCA9IG1hdGNoO1xuZXhwb3J0cy5wYXRoVG9SZWdleHAgPSBwYXRoVG9SZWdleHA7XG5jb25zdCBERUZBVUxUX0RFTElNSVRFUiA9IFwiL1wiO1xuY29uc3QgTk9PUF9WQUxVRSA9ICh2YWx1ZSkgPT4gdmFsdWU7XG5jb25zdCBJRF9DSEFSID0gL15cXHB7WElEX0NvbnRpbnVlfSQvdTtcbmNvbnN0IERFQlVHX1VSTCA9IFwiaHR0cHM6Ly9naXQubmV3L3BhdGhUb1JlZ2V4cEVycm9yXCI7XG5jb25zdCBTSU1QTEVfVE9LRU5TID0ge1xuICAgIFwiIVwiOiBcIiFcIixcbiAgICBcIkBcIjogXCJAXCIsXG4gICAgXCI7XCI6IFwiO1wiLFxuICAgIFwiLFwiOiBcIixcIixcbiAgICBcIipcIjogXCIqXCIsXG4gICAgXCIrXCI6IFwiK1wiLFxuICAgIFwiP1wiOiBcIj9cIixcbiAgICBcIntcIjogXCJ7XCIsXG4gICAgXCJ9XCI6IFwifVwiLFxufTtcbi8qKlxuICogVG9rZW5pemUgaW5wdXQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBsZXhlcihzdHIpIHtcbiAgICBjb25zdCBjaGFycyA9IFsuLi5zdHJdO1xuICAgIGNvbnN0IHRva2VucyA9IFtdO1xuICAgIGxldCBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGNoYXJzLmxlbmd0aCkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGNoYXJzW2ldO1xuICAgICAgICBjb25zdCB0eXBlID0gU0lNUExFX1RPS0VOU1t2YWx1ZV07XG4gICAgICAgIGlmICh0eXBlKSB7XG4gICAgICAgICAgICB0b2tlbnMucHVzaCh7IHR5cGUsIGluZGV4OiBpKyssIHZhbHVlIH0pO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlID09PSBcIlxcXFxcIikge1xuICAgICAgICAgICAgdG9rZW5zLnB1c2goeyB0eXBlOiBcIkVTQ0FQRURcIiwgaW5kZXg6IGkrKywgdmFsdWU6IGNoYXJzW2krK10gfSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgPT09IFwiOlwiKSB7XG4gICAgICAgICAgICBsZXQgbmFtZSA9IFwiXCI7XG4gICAgICAgICAgICB3aGlsZSAoSURfQ0hBUi50ZXN0KGNoYXJzWysraV0pKSB7XG4gICAgICAgICAgICAgICAgbmFtZSArPSBjaGFyc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbmFtZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE1pc3NpbmcgcGFyYW1ldGVyIG5hbWUgYXQgJHtpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG9rZW5zLnB1c2goeyB0eXBlOiBcIk5BTUVcIiwgaW5kZXg6IGksIHZhbHVlOiBuYW1lIH0pO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlID09PSBcIihcIikge1xuICAgICAgICAgICAgY29uc3QgcG9zID0gaSsrO1xuICAgICAgICAgICAgbGV0IGNvdW50ID0gMTtcbiAgICAgICAgICAgIGxldCBwYXR0ZXJuID0gXCJcIjtcbiAgICAgICAgICAgIGlmIChjaGFyc1tpXSA9PT0gXCI/XCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBQYXR0ZXJuIGNhbm5vdCBzdGFydCB3aXRoIFwiP1wiIGF0ICR7aX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChpIDwgY2hhcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoYXJzW2ldID09PSBcIlxcXFxcIikge1xuICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuICs9IGNoYXJzW2krK10gKyBjaGFyc1tpKytdO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNoYXJzW2ldID09PSBcIilcIikge1xuICAgICAgICAgICAgICAgICAgICBjb3VudC0tO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNoYXJzW2ldID09PSBcIihcIikge1xuICAgICAgICAgICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhcnNbaSArIDFdICE9PSBcIj9cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQ2FwdHVyaW5nIGdyb3VwcyBhcmUgbm90IGFsbG93ZWQgYXQgJHtpfWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhdHRlcm4gKz0gY2hhcnNbaSsrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb3VudClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBVbmJhbGFuY2VkIHBhdHRlcm4gYXQgJHtwb3N9YCk7XG4gICAgICAgICAgICBpZiAoIXBhdHRlcm4pXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTWlzc2luZyBwYXR0ZXJuIGF0ICR7cG9zfWApO1xuICAgICAgICAgICAgdG9rZW5zLnB1c2goeyB0eXBlOiBcIlBBVFRFUk5cIiwgaW5kZXg6IGksIHZhbHVlOiBwYXR0ZXJuIH0pO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdG9rZW5zLnB1c2goeyB0eXBlOiBcIkNIQVJcIiwgaW5kZXg6IGksIHZhbHVlOiBjaGFyc1tpKytdIH0pO1xuICAgIH1cbiAgICB0b2tlbnMucHVzaCh7IHR5cGU6IFwiRU5EXCIsIGluZGV4OiBpLCB2YWx1ZTogXCJcIiB9KTtcbiAgICByZXR1cm4gbmV3IEl0ZXIodG9rZW5zKTtcbn1cbmNsYXNzIEl0ZXIge1xuICAgIGNvbnN0cnVjdG9yKHRva2Vucykge1xuICAgICAgICB0aGlzLnRva2VucyA9IHRva2VucztcbiAgICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgfVxuICAgIHBlZWsoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRva2Vuc1t0aGlzLmluZGV4XTtcbiAgICB9XG4gICAgdHJ5Q29uc3VtZSh0eXBlKSB7XG4gICAgICAgIGNvbnN0IHRva2VuID0gdGhpcy5wZWVrKCk7XG4gICAgICAgIGlmICh0b2tlbi50eXBlICE9PSB0eXBlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmluZGV4Kys7XG4gICAgICAgIHJldHVybiB0b2tlbi52YWx1ZTtcbiAgICB9XG4gICAgY29uc3VtZSh0eXBlKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy50cnlDb25zdW1lKHR5cGUpO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgY29uc3QgeyB0eXBlOiBuZXh0VHlwZSwgaW5kZXggfSA9IHRoaXMucGVlaygpO1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBVbmV4cGVjdGVkICR7bmV4dFR5cGV9IGF0ICR7aW5kZXh9LCBleHBlY3RlZCAke3R5cGV9OiAke0RFQlVHX1VSTH1gKTtcbiAgICB9XG4gICAgdGV4dCgpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gICAgICAgIGxldCB2YWx1ZTtcbiAgICAgICAgd2hpbGUgKCh2YWx1ZSA9IHRoaXMudHJ5Q29uc3VtZShcIkNIQVJcIikgfHwgdGhpcy50cnlDb25zdW1lKFwiRVNDQVBFRFwiKSkpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBtb2RpZmllcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJ5Q29uc3VtZShcIj9cIikgfHwgdGhpcy50cnlDb25zdW1lKFwiKlwiKSB8fCB0aGlzLnRyeUNvbnN1bWUoXCIrXCIpO1xuICAgIH1cbn1cbi8qKlxuICogVG9rZW5pemVkIHBhdGggaW5zdGFuY2UuIENhbiB3ZSBwYXNzZWQgYXJvdW5kIGluc3RlYWQgb2Ygc3RyaW5nLlxuICovXG5jbGFzcyBUb2tlbkRhdGEge1xuICAgIGNvbnN0cnVjdG9yKHRva2VucywgZGVsaW1pdGVyKSB7XG4gICAgICAgIHRoaXMudG9rZW5zID0gdG9rZW5zO1xuICAgICAgICB0aGlzLmRlbGltaXRlciA9IGRlbGltaXRlcjtcbiAgICB9XG59XG5leHBvcnRzLlRva2VuRGF0YSA9IFRva2VuRGF0YTtcbi8qKlxuICogUGFyc2UgYSBzdHJpbmcgZm9yIHRoZSByYXcgdG9rZW5zLlxuICovXG5mdW5jdGlvbiBwYXJzZShzdHIsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgZW5jb2RlUGF0aCA9IE5PT1BfVkFMVUUsIGRlbGltaXRlciA9IGVuY29kZVBhdGgoREVGQVVMVF9ERUxJTUlURVIpIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IHRva2VucyA9IFtdO1xuICAgIGNvbnN0IGl0ID0gbGV4ZXIoc3RyKTtcbiAgICBsZXQga2V5ID0gMDtcbiAgICBkbyB7XG4gICAgICAgIGNvbnN0IHBhdGggPSBpdC50ZXh0KCk7XG4gICAgICAgIGlmIChwYXRoKVxuICAgICAgICAgICAgdG9rZW5zLnB1c2goZW5jb2RlUGF0aChwYXRoKSk7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBpdC50cnlDb25zdW1lKFwiTkFNRVwiKTtcbiAgICAgICAgY29uc3QgcGF0dGVybiA9IGl0LnRyeUNvbnN1bWUoXCJQQVRURVJOXCIpO1xuICAgICAgICBpZiAobmFtZSB8fCBwYXR0ZXJuKSB7XG4gICAgICAgICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgbmFtZTogbmFtZSB8fCBTdHJpbmcoa2V5KyspLFxuICAgICAgICAgICAgICAgIHBhdHRlcm4sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IG5leHQgPSBpdC5wZWVrKCk7XG4gICAgICAgICAgICBpZiAobmV4dC50eXBlID09PSBcIipcIikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFVuZXhwZWN0ZWQgKiBhdCAke25leHQuaW5kZXh9LCB5b3UgcHJvYmFibHkgd2FudCBcXGAvKlxcYCBvciBcXGB7Lzpmb299KlxcYDogJHtERUJVR19VUkx9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhc3RlcmlzayA9IGl0LnRyeUNvbnN1bWUoXCIqXCIpO1xuICAgICAgICBpZiAoYXN0ZXJpc2spIHtcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgICAgICAgICBuYW1lOiBTdHJpbmcoa2V5KyspLFxuICAgICAgICAgICAgICAgIHBhdHRlcm46IGAoPzooPyEke2VzY2FwZShkZWxpbWl0ZXIpfSkuKSpgLFxuICAgICAgICAgICAgICAgIG1vZGlmaWVyOiBcIipcIixcbiAgICAgICAgICAgICAgICBzZXBhcmF0b3I6IGRlbGltaXRlcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3BlbiA9IGl0LnRyeUNvbnN1bWUoXCJ7XCIpO1xuICAgICAgICBpZiAob3Blbikge1xuICAgICAgICAgICAgY29uc3QgcHJlZml4ID0gaXQudGV4dCgpO1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IGl0LnRyeUNvbnN1bWUoXCJOQU1FXCIpO1xuICAgICAgICAgICAgY29uc3QgcGF0dGVybiA9IGl0LnRyeUNvbnN1bWUoXCJQQVRURVJOXCIpO1xuICAgICAgICAgICAgY29uc3Qgc3VmZml4ID0gaXQudGV4dCgpO1xuICAgICAgICAgICAgY29uc3Qgc2VwYXJhdG9yID0gaXQudHJ5Q29uc3VtZShcIjtcIikgJiYgaXQudGV4dCgpO1xuICAgICAgICAgICAgaXQuY29uc3VtZShcIn1cIik7XG4gICAgICAgICAgICBjb25zdCBtb2RpZmllciA9IGl0Lm1vZGlmaWVyKCk7XG4gICAgICAgICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgbmFtZTogbmFtZSB8fCAocGF0dGVybiA/IFN0cmluZyhrZXkrKykgOiBcIlwiKSxcbiAgICAgICAgICAgICAgICBwcmVmaXg6IGVuY29kZVBhdGgocHJlZml4KSxcbiAgICAgICAgICAgICAgICBzdWZmaXg6IGVuY29kZVBhdGgoc3VmZml4KSxcbiAgICAgICAgICAgICAgICBwYXR0ZXJuLFxuICAgICAgICAgICAgICAgIG1vZGlmaWVyLFxuICAgICAgICAgICAgICAgIHNlcGFyYXRvcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaXQuY29uc3VtZShcIkVORFwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfSB3aGlsZSAodHJ1ZSk7XG4gICAgcmV0dXJuIG5ldyBUb2tlbkRhdGEodG9rZW5zLCBkZWxpbWl0ZXIpO1xufVxuLyoqXG4gKiBDb21waWxlIGEgc3RyaW5nIHRvIGEgdGVtcGxhdGUgZnVuY3Rpb24gZm9yIHRoZSBwYXRoLlxuICovXG5mdW5jdGlvbiBjb21waWxlKHBhdGgsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IGRhdGEgPSBwYXRoIGluc3RhbmNlb2YgVG9rZW5EYXRhID8gcGF0aCA6IHBhcnNlKHBhdGgsIG9wdGlvbnMpO1xuICAgIHJldHVybiBjb21waWxlVG9rZW5zKGRhdGEsIG9wdGlvbnMpO1xufVxuLyoqXG4gKiBDb252ZXJ0IGEgc2luZ2xlIHRva2VuIGludG8gYSBwYXRoIGJ1aWxkaW5nIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiB0b2tlblRvRnVuY3Rpb24odG9rZW4sIGVuY29kZSkge1xuICAgIGlmICh0eXBlb2YgdG9rZW4gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuICgpID0+IHRva2VuO1xuICAgIH1cbiAgICBjb25zdCBlbmNvZGVWYWx1ZSA9IGVuY29kZSB8fCBOT09QX1ZBTFVFO1xuICAgIGNvbnN0IHJlcGVhdGVkID0gdG9rZW4ubW9kaWZpZXIgPT09IFwiK1wiIHx8IHRva2VuLm1vZGlmaWVyID09PSBcIipcIjtcbiAgICBjb25zdCBvcHRpb25hbCA9IHRva2VuLm1vZGlmaWVyID09PSBcIj9cIiB8fCB0b2tlbi5tb2RpZmllciA9PT0gXCIqXCI7XG4gICAgY29uc3QgeyBwcmVmaXggPSBcIlwiLCBzdWZmaXggPSBcIlwiLCBzZXBhcmF0b3IgPSBzdWZmaXggKyBwcmVmaXggfSA9IHRva2VuO1xuICAgIGlmIChlbmNvZGUgJiYgcmVwZWF0ZWQpIHtcbiAgICAgICAgY29uc3Qgc3RyaW5naWZ5ID0gKHZhbHVlLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIFwiJHt0b2tlbi5uYW1lfS8ke2luZGV4fVwiIHRvIGJlIGEgc3RyaW5nYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZW5jb2RlVmFsdWUodmFsdWUpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjb21waWxlID0gKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgXCIke3Rva2VuLm5hbWV9XCIgdG8gYmUgYW4gYXJyYXlgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgICAgICByZXR1cm4gcHJlZml4ICsgdmFsdWUubWFwKHN0cmluZ2lmeSkuam9pbihzZXBhcmF0b3IpICsgc3VmZml4O1xuICAgICAgICB9O1xuICAgICAgICBpZiAob3B0aW9uYWwpIHtcbiAgICAgICAgICAgIHJldHVybiAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZGF0YVt0b2tlbi5uYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLmxlbmd0aCA/IGNvbXBpbGUodmFsdWUpIDogXCJcIjtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChkYXRhKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGRhdGFbdG9rZW4ubmFtZV07XG4gICAgICAgICAgICByZXR1cm4gY29tcGlsZSh2YWx1ZSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHN0cmluZ2lmeSA9ICh2YWx1ZSkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCBcIiR7dG9rZW4ubmFtZX1cIiB0byBiZSBhIHN0cmluZ2ApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcmVmaXggKyBlbmNvZGVWYWx1ZSh2YWx1ZSkgKyBzdWZmaXg7XG4gICAgfTtcbiAgICBpZiAob3B0aW9uYWwpIHtcbiAgICAgICAgcmV0dXJuIChkYXRhKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGRhdGFbdG9rZW4ubmFtZV07XG4gICAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmdpZnkodmFsdWUpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gKGRhdGEpID0+IHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBkYXRhW3Rva2VuLm5hbWVdO1xuICAgICAgICByZXR1cm4gc3RyaW5naWZ5KHZhbHVlKTtcbiAgICB9O1xufVxuLyoqXG4gKiBUcmFuc2Zvcm0gdG9rZW5zIGludG8gYSBwYXRoIGJ1aWxkaW5nIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjb21waWxlVG9rZW5zKGRhdGEsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGVuY29kZSA9IGVuY29kZVVSSUNvbXBvbmVudCwgbG9vc2UgPSB0cnVlLCB2YWxpZGF0ZSA9IHRydWUsIHN0cmljdCA9IGZhbHNlLCB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBmbGFncyA9IHRvRmxhZ3Mob3B0aW9ucyk7XG4gICAgY29uc3Qgc3RyaW5naWZ5ID0gdG9TdHJpbmdpZnkobG9vc2UsIGRhdGEuZGVsaW1pdGVyKTtcbiAgICBjb25zdCBzb3VyY2VzID0gdG9SZWdFeHBTb3VyY2UoZGF0YSwgc3RyaW5naWZ5LCBbXSwgZmxhZ3MsIHN0cmljdCk7XG4gICAgLy8gQ29tcGlsZSBhbGwgdGhlIHRva2VucyBpbnRvIHJlZ2V4cHMuXG4gICAgY29uc3QgZW5jb2RlcnMgPSBkYXRhLnRva2Vucy5tYXAoKHRva2VuLCBpbmRleCkgPT4ge1xuICAgICAgICBjb25zdCBmbiA9IHRva2VuVG9GdW5jdGlvbih0b2tlbiwgZW5jb2RlKTtcbiAgICAgICAgaWYgKCF2YWxpZGF0ZSB8fCB0eXBlb2YgdG9rZW4gPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICByZXR1cm4gZm47XG4gICAgICAgIGNvbnN0IHZhbGlkUmUgPSBuZXcgUmVnRXhwKGBeJHtzb3VyY2VzW2luZGV4XX0kYCwgZmxhZ3MpO1xuICAgICAgICByZXR1cm4gKGRhdGEpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZm4oZGF0YSk7XG4gICAgICAgICAgICBpZiAoIXZhbGlkUmUudGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIHZhbHVlIGZvciBcIiR7dG9rZW4ubmFtZX1cIjogJHtKU09OLnN0cmluZ2lmeSh2YWx1ZSl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHBhdGgoZGF0YSA9IHt9KSB7XG4gICAgICAgIGxldCBwYXRoID0gXCJcIjtcbiAgICAgICAgZm9yIChjb25zdCBlbmNvZGVyIG9mIGVuY29kZXJzKVxuICAgICAgICAgICAgcGF0aCArPSBlbmNvZGVyKGRhdGEpO1xuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICB9O1xufVxuLyoqXG4gKiBDcmVhdGUgcGF0aCBtYXRjaCBmdW5jdGlvbiBmcm9tIGBwYXRoLXRvLXJlZ2V4cGAgc3BlYy5cbiAqL1xuZnVuY3Rpb24gbWF0Y2gocGF0aCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBkZWNvZGUgPSBkZWNvZGVVUklDb21wb25lbnQsIGxvb3NlID0gdHJ1ZSB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBkYXRhID0gcGF0aCBpbnN0YW5jZW9mIFRva2VuRGF0YSA/IHBhdGggOiBwYXJzZShwYXRoLCBvcHRpb25zKTtcbiAgICBjb25zdCBzdHJpbmdpZnkgPSB0b1N0cmluZ2lmeShsb29zZSwgZGF0YS5kZWxpbWl0ZXIpO1xuICAgIGNvbnN0IGtleXMgPSBbXTtcbiAgICBjb25zdCByZSA9IHRva2Vuc1RvUmVnZXhwKGRhdGEsIGtleXMsIG9wdGlvbnMpO1xuICAgIGNvbnN0IGRlY29kZXJzID0ga2V5cy5tYXAoKGtleSkgPT4ge1xuICAgICAgICBpZiAoZGVjb2RlICYmIChrZXkubW9kaWZpZXIgPT09IFwiK1wiIHx8IGtleS5tb2RpZmllciA9PT0gXCIqXCIpKSB7XG4gICAgICAgICAgICBjb25zdCB7IHByZWZpeCA9IFwiXCIsIHN1ZmZpeCA9IFwiXCIsIHNlcGFyYXRvciA9IHN1ZmZpeCArIHByZWZpeCB9ID0ga2V5O1xuICAgICAgICAgICAgY29uc3QgcmUgPSBuZXcgUmVnRXhwKHN0cmluZ2lmeShzZXBhcmF0b3IpLCBcImdcIik7XG4gICAgICAgICAgICByZXR1cm4gKHZhbHVlKSA9PiB2YWx1ZS5zcGxpdChyZSkubWFwKGRlY29kZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlY29kZSB8fCBOT09QX1ZBTFVFO1xuICAgIH0pO1xuICAgIHJldHVybiBmdW5jdGlvbiBtYXRjaChpbnB1dCkge1xuICAgICAgICBjb25zdCBtID0gcmUuZXhlYyhpbnB1dCk7XG4gICAgICAgIGlmICghbSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY29uc3QgeyAwOiBwYXRoLCBpbmRleCB9ID0gbTtcbiAgICAgICAgY29uc3QgcGFyYW1zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBtLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAobVtpXSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tpIC0gMV07XG4gICAgICAgICAgICBjb25zdCBkZWNvZGVyID0gZGVjb2RlcnNbaSAtIDFdO1xuICAgICAgICAgICAgcGFyYW1zW2tleS5uYW1lXSA9IGRlY29kZXIobVtpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgcGF0aCwgaW5kZXgsIHBhcmFtcyB9O1xuICAgIH07XG59XG4vKipcbiAqIEVzY2FwZSBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGVzY2FwZShzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoLyhbLisqP14ke30oKVtcXF18L1xcXFxdKS9nLCBcIlxcXFwkMVwiKTtcbn1cbi8qKlxuICogRXNjYXBlIGFuZCByZXBlYXQgbG9vc2UgY2hhcmFjdGVycyBmb3IgcmVndWxhciBleHByZXNzaW9ucy5cbiAqL1xuZnVuY3Rpb24gbG9vc2VSZXBsYWNlcih2YWx1ZSwgbG9vc2UpIHtcbiAgICBjb25zdCBlc2NhcGVkID0gZXNjYXBlKHZhbHVlKTtcbiAgICByZXR1cm4gbG9vc2UgPyBgKD86JHtlc2NhcGVkfSkrKD8hJHtlc2NhcGVkfSlgIDogZXNjYXBlZDtcbn1cbi8qKlxuICogRW5jb2RlIGFsbCBub24tZGVsaW1pdGVyIGNoYXJhY3RlcnMgdXNpbmcgdGhlIGVuY29kZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gdG9TdHJpbmdpZnkobG9vc2UsIGRlbGltaXRlcikge1xuICAgIGlmICghbG9vc2UpXG4gICAgICAgIHJldHVybiBlc2NhcGU7XG4gICAgY29uc3QgcmUgPSBuZXcgUmVnRXhwKGAoPzooPyEke2VzY2FwZShkZWxpbWl0ZXIpfSkuKSt8KC4pYCwgXCJnXCIpO1xuICAgIHJldHVybiAodmFsdWUpID0+IHZhbHVlLnJlcGxhY2UocmUsIGxvb3NlUmVwbGFjZXIpO1xufVxuLyoqXG4gKiBHZXQgdGhlIGZsYWdzIGZvciBhIHJlZ2V4cCBmcm9tIHRoZSBvcHRpb25zLlxuICovXG5mdW5jdGlvbiB0b0ZsYWdzKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5zZW5zaXRpdmUgPyBcIlwiIDogXCJpXCI7XG59XG4vKipcbiAqIEV4cG9zZSBhIGZ1bmN0aW9uIGZvciB0YWtpbmcgdG9rZW5zIGFuZCByZXR1cm5pbmcgYSBSZWdFeHAuXG4gKi9cbmZ1bmN0aW9uIHRva2Vuc1RvUmVnZXhwKGRhdGEsIGtleXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IHRyYWlsaW5nID0gdHJ1ZSwgbG9vc2UgPSB0cnVlLCBzdGFydCA9IHRydWUsIGVuZCA9IHRydWUsIHN0cmljdCA9IGZhbHNlLCB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBmbGFncyA9IHRvRmxhZ3Mob3B0aW9ucyk7XG4gICAgY29uc3Qgc3RyaW5naWZ5ID0gdG9TdHJpbmdpZnkobG9vc2UsIGRhdGEuZGVsaW1pdGVyKTtcbiAgICBjb25zdCBzb3VyY2VzID0gdG9SZWdFeHBTb3VyY2UoZGF0YSwgc3RyaW5naWZ5LCBrZXlzLCBmbGFncywgc3RyaWN0KTtcbiAgICBsZXQgcGF0dGVybiA9IHN0YXJ0ID8gXCJeXCIgOiBcIlwiO1xuICAgIHBhdHRlcm4gKz0gc291cmNlcy5qb2luKFwiXCIpO1xuICAgIGlmICh0cmFpbGluZylcbiAgICAgICAgcGF0dGVybiArPSBgKD86JHtzdHJpbmdpZnkoZGF0YS5kZWxpbWl0ZXIpfSk/YDtcbiAgICBwYXR0ZXJuICs9IGVuZCA/IFwiJFwiIDogYCg/PSR7ZXNjYXBlKGRhdGEuZGVsaW1pdGVyKX18JClgO1xuICAgIHJldHVybiBuZXcgUmVnRXhwKHBhdHRlcm4sIGZsYWdzKTtcbn1cbi8qKlxuICogQ29udmVydCBhIHRva2VuIGludG8gYSByZWdleHAgc3RyaW5nIChyZS11c2VkIGZvciBwYXRoIHZhbGlkYXRpb24pLlxuICovXG5mdW5jdGlvbiB0b1JlZ0V4cFNvdXJjZShkYXRhLCBzdHJpbmdpZnksIGtleXMsIGZsYWdzLCBzdHJpY3QpIHtcbiAgICBjb25zdCBkZWZhdWx0UGF0dGVybiA9IGAoPzooPyEke2VzY2FwZShkYXRhLmRlbGltaXRlcil9KS4pKz9gO1xuICAgIGxldCBiYWNrdHJhY2sgPSBcIlwiO1xuICAgIGxldCBzYWZlID0gdHJ1ZTtcbiAgICByZXR1cm4gZGF0YS50b2tlbnMubWFwKCh0b2tlbiwgaW5kZXgpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgYmFja3RyYWNrID0gdG9rZW47XG4gICAgICAgICAgICByZXR1cm4gc3RyaW5naWZ5KHRva2VuKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHByZWZpeCA9IFwiXCIsIHN1ZmZpeCA9IFwiXCIsIHNlcGFyYXRvciA9IHN1ZmZpeCArIHByZWZpeCwgbW9kaWZpZXIgPSBcIlwiLCB9ID0gdG9rZW47XG4gICAgICAgIGNvbnN0IHByZSA9IHN0cmluZ2lmeShwcmVmaXgpO1xuICAgICAgICBjb25zdCBwb3N0ID0gc3RyaW5naWZ5KHN1ZmZpeCk7XG4gICAgICAgIGlmICh0b2tlbi5uYW1lKSB7XG4gICAgICAgICAgICBjb25zdCBwYXR0ZXJuID0gdG9rZW4ucGF0dGVybiA/IGAoPzoke3Rva2VuLnBhdHRlcm59KWAgOiBkZWZhdWx0UGF0dGVybjtcbiAgICAgICAgICAgIGNvbnN0IHJlID0gY2hlY2tQYXR0ZXJuKHBhdHRlcm4sIHRva2VuLm5hbWUsIGZsYWdzKTtcbiAgICAgICAgICAgIHNhZmUgfHwgKHNhZmUgPSBzYWZlUGF0dGVybihyZSwgcHJlZml4IHx8IGJhY2t0cmFjaykpO1xuICAgICAgICAgICAgaWYgKCFzYWZlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQW1iaWd1b3VzIHBhdHRlcm4gZm9yIFwiJHt0b2tlbi5uYW1lfVwiOiAke0RFQlVHX1VSTH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNhZmUgPSAhc3RyaWN0IHx8IHNhZmVQYXR0ZXJuKHJlLCBzdWZmaXgpO1xuICAgICAgICAgICAgYmFja3RyYWNrID0gXCJcIjtcbiAgICAgICAgICAgIGtleXMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICBpZiAobW9kaWZpZXIgPT09IFwiK1wiIHx8IG1vZGlmaWVyID09PSBcIipcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1vZCA9IG1vZGlmaWVyID09PSBcIipcIiA/IFwiP1wiIDogXCJcIjtcbiAgICAgICAgICAgICAgICBjb25zdCBzZXAgPSBzdHJpbmdpZnkoc2VwYXJhdG9yKTtcbiAgICAgICAgICAgICAgICBpZiAoIXNlcCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBNaXNzaW5nIHNlcGFyYXRvciBmb3IgXCIke3Rva2VuLm5hbWV9XCI6ICR7REVCVUdfVVJMfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzYWZlIHx8IChzYWZlID0gIXN0cmljdCB8fCBzYWZlUGF0dGVybihyZSwgc2VwYXJhdG9yKSk7XG4gICAgICAgICAgICAgICAgaWYgKCFzYWZlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEFtYmlndW91cyBwYXR0ZXJuIGZvciBcIiR7dG9rZW4ubmFtZX1cIiBzZXBhcmF0b3I6ICR7REVCVUdfVVJMfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzYWZlID0gIXN0cmljdDtcbiAgICAgICAgICAgICAgICByZXR1cm4gYCg/OiR7cHJlfSgke3BhdHRlcm59KD86JHtzZXB9JHtwYXR0ZXJufSkqKSR7cG9zdH0pJHttb2R9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBgKD86JHtwcmV9KCR7cGF0dGVybn0pJHtwb3N0fSkke21vZGlmaWVyfWA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGAoPzoke3ByZX0ke3Bvc3R9KSR7bW9kaWZpZXJ9YDtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGNoZWNrUGF0dGVybihwYXR0ZXJuLCBuYW1lLCBmbGFncykge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVnRXhwKGBeJHtwYXR0ZXJufSRgLCBmbGFncyk7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBwYXR0ZXJuIGZvciBcIiR7bmFtZX1cIjogJHtlcnIubWVzc2FnZX1gKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzYWZlUGF0dGVybihyZSwgdmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPyAhcmUudGVzdCh2YWx1ZSkgOiBmYWxzZTtcbn1cbi8qKlxuICogTm9ybWFsaXplIHRoZSBnaXZlbiBwYXRoIHN0cmluZywgcmV0dXJuaW5nIGEgcmVndWxhciBleHByZXNzaW9uLlxuICpcbiAqIEFuIGVtcHR5IGFycmF5IGNhbiBiZSBwYXNzZWQgaW4gZm9yIHRoZSBrZXlzLCB3aGljaCB3aWxsIGhvbGQgdGhlXG4gKiBwbGFjZWhvbGRlciBrZXkgZGVzY3JpcHRpb25zLiBGb3IgZXhhbXBsZSwgdXNpbmcgYC91c2VyLzppZGAsIGBrZXlzYCB3aWxsXG4gKiBjb250YWluIGBbeyBuYW1lOiAnaWQnLCBkZWxpbWl0ZXI6ICcvJywgb3B0aW9uYWw6IGZhbHNlLCByZXBlYXQ6IGZhbHNlIH1dYC5cbiAqL1xuZnVuY3Rpb24gcGF0aFRvUmVnZXhwKHBhdGgsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IGRhdGEgPSBwYXRoIGluc3RhbmNlb2YgVG9rZW5EYXRhID8gcGF0aCA6IHBhcnNlKHBhdGgsIG9wdGlvbnMpO1xuICAgIGNvbnN0IGtleXMgPSBbXTtcbiAgICBjb25zdCByZWdleHAgPSB0b2tlbnNUb1JlZ2V4cChkYXRhLCBrZXlzLCBvcHRpb25zKTtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihyZWdleHAsIHsga2V5cyB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(middleware)/./node_modules/path-to-regexp/dist/index.js\n");

/***/ }),

/***/ "(middleware)/./src/middleware.ts":
/*!***************************!*\
  !*** ./src/middleware.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   config: () => (/* binding */ config),\n/* harmony export */   middleware: () => (/* binding */ middleware)\n/* harmony export */ });\n/* harmony import */ var next_easy_middlewares__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next-easy-middlewares */ \"(middleware)/./node_modules/next-easy-middlewares/dist/index.js\");\n/* harmony import */ var _utils_middleware_class__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/utils/middleware-class */ \"(middleware)/./src/utils/middleware-class.ts\");\n\n\nconst middlewareUtils = new _utils_middleware_class__WEBPACK_IMPORTED_MODULE_1__[\"default\"]();\nconst globalMiddlewares = {\n    before: middlewareUtils.isUserAuthenticated()\n};\nconst middlewares = {\n    \"/\": [\n        async ({ request, response })=>{\n            console.log(\"Hello from next-easy-middlewares\", request.nextUrl.pathname);\n            return response;\n        }\n    ]\n};\nconst middleware = (0,next_easy_middlewares__WEBPACK_IMPORTED_MODULE_0__.createMiddleware)(middlewares, globalMiddlewares);\nconst config = {\n    matcher: [\n        \"/((?!.*\\\\..*|_next|public|public/.*|.*\\\\.css$).*)\",\n        \"/\",\n        \"/(api|trpc)(.*)\"\n    ]\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKG1pZGRsZXdhcmUpLy4vc3JjL21pZGRsZXdhcmUudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFnSDtBQUN6RDtBQUV2RCxNQUFNRSxrQkFBa0IsSUFBSUQsK0RBQWVBO0FBRTNDLE1BQU1FLG9CQUFvQjtJQUN4QkMsUUFBUUYsZ0JBQWdCRyxtQkFBbUI7QUFDN0M7QUFFQSxNQUFNQyxjQUFjO0lBQ2xCLEtBQUs7UUFDSCxPQUFPLEVBQUNDLE9BQU8sRUFBRUMsUUFBUSxFQUEwQjtZQUNqREMsUUFBUUMsR0FBRyxDQUFDLG9DQUFvQ0gsUUFBUUksT0FBTyxDQUFDQyxRQUFRO1lBQ3hFLE9BQU9KO1FBQ1Q7S0FDRDtBQUNIO0FBRU8sTUFBTUssYUFBYWIsdUVBQWdCQSxDQUFDTSxhQUFhSCxtQkFBbUI7QUFFcEUsTUFBTVcsU0FBUztJQUNwQkMsU0FBUztRQUNQO1FBQ0E7UUFDQTtLQUNEO0FBQ0gsRUFBRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvbWlkZGxld2FyZS50cz9kMTk5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZU1pZGRsZXdhcmUsIHR5cGUgTWlkZGxld2FyZUZ1bmN0aW9uUHJvcHMsIHR5cGUgTWlkZGxld2FyZUZ1bmN0aW9uIH0gZnJvbSAnbmV4dC1lYXN5LW1pZGRsZXdhcmVzJztcclxuaW1wb3J0IE1pZGRsZXdhcmVVdGlscyBmcm9tIFwiQC91dGlscy9taWRkbGV3YXJlLWNsYXNzXCI7XHJcblxyXG5jb25zdCBtaWRkbGV3YXJlVXRpbHMgPSBuZXcgTWlkZGxld2FyZVV0aWxzKClcclxuXHJcbmNvbnN0IGdsb2JhbE1pZGRsZXdhcmVzID0ge1xyXG4gIGJlZm9yZTogbWlkZGxld2FyZVV0aWxzLmlzVXNlckF1dGhlbnRpY2F0ZWQoKSBhcyBNaWRkbGV3YXJlRnVuY3Rpb25cclxufTtcclxuXHJcbmNvbnN0IG1pZGRsZXdhcmVzID0ge1xyXG4gICcvJzogW1xyXG4gICAgYXN5bmMgKHtyZXF1ZXN0LCByZXNwb25zZX06IE1pZGRsZXdhcmVGdW5jdGlvblByb3BzKSA9PiB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdIZWxsbyBmcm9tIG5leHQtZWFzeS1taWRkbGV3YXJlcycsIHJlcXVlc3QubmV4dFVybC5wYXRobmFtZSk7XHJcbiAgICAgIHJldHVybiByZXNwb25zZTtcclxuICAgIH0sXHJcbiAgXSxcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBtaWRkbGV3YXJlID0gY3JlYXRlTWlkZGxld2FyZShtaWRkbGV3YXJlcywgZ2xvYmFsTWlkZGxld2FyZXMpO1xyXG5cclxuZXhwb3J0IGNvbnN0IGNvbmZpZyA9IHtcclxuICBtYXRjaGVyOiBbXHJcbiAgICBcIi8oKD8hLipcXFxcLi4qfF9uZXh0fHB1YmxpY3xwdWJsaWMvLip8LipcXFxcLmNzcyQpLiopXCIsXHJcbiAgICBcIi9cIixcclxuICAgIFwiLyhhcGl8dHJwYykoLiopXCJcclxuICBdXHJcbn07Il0sIm5hbWVzIjpbImNyZWF0ZU1pZGRsZXdhcmUiLCJNaWRkbGV3YXJlVXRpbHMiLCJtaWRkbGV3YXJlVXRpbHMiLCJnbG9iYWxNaWRkbGV3YXJlcyIsImJlZm9yZSIsImlzVXNlckF1dGhlbnRpY2F0ZWQiLCJtaWRkbGV3YXJlcyIsInJlcXVlc3QiLCJyZXNwb25zZSIsImNvbnNvbGUiLCJsb2ciLCJuZXh0VXJsIiwicGF0aG5hbWUiLCJtaWRkbGV3YXJlIiwiY29uZmlnIiwibWF0Y2hlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(middleware)/./src/middleware.ts\n");

/***/ }),

/***/ "(middleware)/./node_modules/next-easy-middlewares/dist/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/next-easy-middlewares/dist/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createMiddleware: () => (/* binding */ m)\n/* harmony export */ });\n/* harmony import */ var next_server__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/server */ \"(middleware)/./node_modules/next/dist/esm/api/server.js\");\n/* harmony import */ var path_to_regexp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path-to-regexp */ \"(middleware)/./node_modules/path-to-regexp/dist/index.js\");\nfunction m(e,t){let s=new Map;return async(o,a)=>{let n=o.nextUrl.pathname||\"/\",r=[],i=[];t?.before&&(Array.isArray(t.before)?r=t.before.filter(Boolean).flat():r=[t.before].filter(Boolean).flat()),t?.after&&(Array.isArray(t.after)?i=t.after.filter(Boolean).flat():i=[t.after].filter(Boolean).flat());let u=[...r.flat(),...Object.entries(e).filter(([d])=>R(d,n)).flatMap(([,d])=>d),...i.flat()],c=next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.next();for(let d of u)c=await l(o,d,c,a,s),o=N(o,c);return c}}async function l(e,t,s,o,a){let n=w(await t({request:e,response:s,event:o,context:a}));return s&&s.headers.forEach((r,i)=>{n.headers.set(i,r)}),n.cookies.getAll().forEach(r=>{e.cookies.set(r)}),h(n)&&e.headers.set(\"x-redirect-url\",n.headers.get(\"location\")??\"\"),n}function R(e,t){return (0,path_to_regexp__WEBPACK_IMPORTED_MODULE_1__.pathToRegexp)(e).test(t)}function h(e){return!!(e&&[301,302,303,307,308].includes(e.status))}function N(e,t){let s=new Headers(e.headers);t.headers.forEach((n,r)=>{s.set(r,n)});let o=new URL(e.url),a=new next_server__WEBPACK_IMPORTED_MODULE_0__.NextRequest(o,{headers:s,method:e.method,body:e.body,referrer:e.referrer});return t.cookies.getAll().forEach(n=>{a.cookies.set(n.name,n.value)}),a}function w(e){if(e instanceof next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse)return e;let t=new next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse(e.body,{status:e.status,statusText:e.statusText,headers:e.headers});return e.headers.forEach((s,o)=>{t.headers.set(o,s)}),t}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKG1pZGRsZXdhcmUpLy4vbm9kZV9tb2R1bGVzL25leHQtZWFzeS1taWRkbGV3YXJlcy9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUEwRyxnQkFBZ0IsY0FBYyxvQkFBb0Isd0NBQXdDLGtOQUFrTixnR0FBZ0cscURBQUMsUUFBUSw2Q0FBNkMsVUFBVSw0QkFBNEIsaUJBQWlCLHVDQUF1QyxHQUFHLG9DQUFvQyxtQkFBbUIsaUNBQWlDLGlCQUFpQix3RUFBd0UsZ0JBQWdCLE9BQU8sNERBQUMsWUFBWSxjQUFjLHNEQUFzRCxnQkFBZ0IsNkJBQTZCLDBCQUEwQixXQUFXLEVBQUUsMkJBQTJCLG9EQUFDLElBQUksMERBQTBELEVBQUUsc0NBQXNDLDhCQUE4QixJQUFJLGNBQWMsZ0JBQWdCLHFEQUFDLFVBQVUsVUFBVSxxREFBQyxTQUFTLDBEQUEwRCxFQUFFLGlDQUFpQyxtQkFBbUIsSUFBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQtZWFzeS1taWRkbGV3YXJlcy9kaXN0L2luZGV4LmpzPzBhNmYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0e05leHRSZXF1ZXN0IGFzIHAsTmV4dFJlc3BvbnNlIGFzIGZ9ZnJvbVwibmV4dC9zZXJ2ZXJcIjtpbXBvcnR7cGF0aFRvUmVnZXhwIGFzIHh9ZnJvbVwicGF0aC10by1yZWdleHBcIjtmdW5jdGlvbiBtKGUsdCl7bGV0IHM9bmV3IE1hcDtyZXR1cm4gYXN5bmMobyxhKT0+e2xldCBuPW8ubmV4dFVybC5wYXRobmFtZXx8XCIvXCIscj1bXSxpPVtdO3Q/LmJlZm9yZSYmKEFycmF5LmlzQXJyYXkodC5iZWZvcmUpP3I9dC5iZWZvcmUuZmlsdGVyKEJvb2xlYW4pLmZsYXQoKTpyPVt0LmJlZm9yZV0uZmlsdGVyKEJvb2xlYW4pLmZsYXQoKSksdD8uYWZ0ZXImJihBcnJheS5pc0FycmF5KHQuYWZ0ZXIpP2k9dC5hZnRlci5maWx0ZXIoQm9vbGVhbikuZmxhdCgpOmk9W3QuYWZ0ZXJdLmZpbHRlcihCb29sZWFuKS5mbGF0KCkpO2xldCB1PVsuLi5yLmZsYXQoKSwuLi5PYmplY3QuZW50cmllcyhlKS5maWx0ZXIoKFtkXSk9PlIoZCxuKSkuZmxhdE1hcCgoWyxkXSk9PmQpLC4uLmkuZmxhdCgpXSxjPWYubmV4dCgpO2ZvcihsZXQgZCBvZiB1KWM9YXdhaXQgbChvLGQsYyxhLHMpLG89TihvLGMpO3JldHVybiBjfX1hc3luYyBmdW5jdGlvbiBsKGUsdCxzLG8sYSl7bGV0IG49dyhhd2FpdCB0KHtyZXF1ZXN0OmUscmVzcG9uc2U6cyxldmVudDpvLGNvbnRleHQ6YX0pKTtyZXR1cm4gcyYmcy5oZWFkZXJzLmZvckVhY2goKHIsaSk9PntuLmhlYWRlcnMuc2V0KGkscil9KSxuLmNvb2tpZXMuZ2V0QWxsKCkuZm9yRWFjaChyPT57ZS5jb29raWVzLnNldChyKX0pLGgobikmJmUuaGVhZGVycy5zZXQoXCJ4LXJlZGlyZWN0LXVybFwiLG4uaGVhZGVycy5nZXQoXCJsb2NhdGlvblwiKT8/XCJcIiksbn1mdW5jdGlvbiBSKGUsdCl7cmV0dXJuIHgoZSkudGVzdCh0KX1mdW5jdGlvbiBoKGUpe3JldHVybiEhKGUmJlszMDEsMzAyLDMwMywzMDcsMzA4XS5pbmNsdWRlcyhlLnN0YXR1cykpfWZ1bmN0aW9uIE4oZSx0KXtsZXQgcz1uZXcgSGVhZGVycyhlLmhlYWRlcnMpO3QuaGVhZGVycy5mb3JFYWNoKChuLHIpPT57cy5zZXQocixuKX0pO2xldCBvPW5ldyBVUkwoZS51cmwpLGE9bmV3IHAobyx7aGVhZGVyczpzLG1ldGhvZDplLm1ldGhvZCxib2R5OmUuYm9keSxyZWZlcnJlcjplLnJlZmVycmVyfSk7cmV0dXJuIHQuY29va2llcy5nZXRBbGwoKS5mb3JFYWNoKG49PnthLmNvb2tpZXMuc2V0KG4ubmFtZSxuLnZhbHVlKX0pLGF9ZnVuY3Rpb24gdyhlKXtpZihlIGluc3RhbmNlb2YgZilyZXR1cm4gZTtsZXQgdD1uZXcgZihlLmJvZHkse3N0YXR1czplLnN0YXR1cyxzdGF0dXNUZXh0OmUuc3RhdHVzVGV4dCxoZWFkZXJzOmUuaGVhZGVyc30pO3JldHVybiBlLmhlYWRlcnMuZm9yRWFjaCgocyxvKT0+e3QuaGVhZGVycy5zZXQobyxzKX0pLHR9ZXhwb3J0e20gYXMgY3JlYXRlTWlkZGxld2FyZX07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(middleware)/./node_modules/next-easy-middlewares/dist/index.js\n");

/***/ })

});